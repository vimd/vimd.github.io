---
title: 那些年，碰到的问题

date: 2017-07-29 21:57:46
categories: Linux
---

&emsp;&emsp;工作的过程中总是会遇到各种各样的问题，有时候解决了，但是一段时间后再碰到时又忘记了，现在索性记下来方便以后查阅。

### 1、Android下C和Java中间使用socket的IPC
&emsp;&emsp;最近做项目碰到了需要C程序和Java程序间的通信，由于是本地的进程间通信，所以就使用了Unix Domain Socket。服务端用Java写的，使用LocalServerSocket类：LocalServerSocket lss = new LocalServerSocket(name);这一句相当于C中调用了socket、bind和listen三个函数，然后在调用该对象的accept函数就可以了。这本来没有什么问题，关键在于LocalServerSocket类的构造函数中的name参数，Google官网上对这个构造函数的解释有这么一句： the name is created in the Linux abstract namespace (instead of on the filesystem).（[LocalServerSocket]("http://developer.android.com/reference/android/net/LocalServerSocket.html"))。可以看到这个socket不是在文件系统中创建的（普通的Unix Domain Socket创建后会在某个目录下有个socket文件，比如：dev/socket/mysocket），而是在所谓的“抽象的命名空间”中创建的，这就决定了客户端不能用普通的socket函数来获得一个socket文件描述符，得使用cutils库中的socket_local_client函数（需要#include <cutils/sockets.h>)，并且第二个参数要指定为：ANDROID\_SOCKET\_NAMESPACE\_ABSTRACT。

### 2、大端小端以及数字和数字对应的字符
&emsp;&emsp;同事碰到一个问题：用Java通过socket把字符串“1512”传给C程序，C程序再通过memcpy函数把它拷贝到一个int型变量的地址空间，结果却变成了8亿多。他问我的时候，我第一感觉是大端小端的问题，我把1512用大端法计算了一下结果，是33621249（0x02010501，我是按一个字符两个字节来算的）。我实在想不到是什么原因了，当时我也不知道那个8亿多的数字具体是多少，由于到下班时间了，就走了。第二天我自己试了一下，确实是8亿多，然我我把它转换成十六进制表示是：0x32313531。看到这串数字的一刹那我都明白了：大端小端确实是问题之一，而另外一个则是字符“1”和数字1的问题。数字1在内存里用一个字节表示就是0x01，但是字符“1”在内存里的表示却是0x31（就是它的ASCII码，十进制为49），所以当我看到那串十六进制的时候就如醍醐灌顶。

&emsp;&emsp;事情并没有就这么结束，因为我还有两个问题没有明白：一个是Java是按大端来发送的，但是C程序却是用小端来存储的（其实是和处理器有关，我那个机器的处理器是小端的），那么为什么传过来的不是“2151”？另一个是Java里的字符是用两个字节存的，而C程序是按一个字节存的，但是为什么发送过来的却是正确的呢？

&emsp;&emsp;我想了一下发现第一个问题比较白痴， 大端和小端是相对于一个数据来说的，而“1512”在Java中相当于是四个数据（四个char），所以不管大端小端，这个顺序都不会变得。举个例子，假设一个字符是两字节，那么上面的字符串用大端在内存中的表示就是“0031003500321032”，小端的表示为“31003500310032”，看到了吗，不管大端小端，整体的顺序都是“1512”，只是具体到“1”这个数据的时候才会有“0031”和“3100”的区别。

&emsp;&emsp;对于第二个问题，就和字符集有关了。Java通过socket给C程序发送字符串时需要把字符串转换成字节数组，Java的String对象有一个getBytes()函数可以做到。如果不给参数这是使用默认的字符集把String编码byte序列，我用的机器的默认字符集恰好是“UFT-8”，每个字符是一个字节编码的，所以无所谓大端小端（因为只有一个字节）。如果给getBytes传一个“UTF-16LE”参数（字符用十六位的小端法编码），当传“abc”给C程序，那么打印的将是“a”。为什么呢？因为是十六位小端编码，所以“abc”的字节编码为：\97\0\98\0\99\0。而C程序接收到的是：\97\0\98\0\99\0。由于C程序认为\0是字符串的结束符，所以只打印\97，即“a”。相应的，如果使用“UTF-16BE”（十六位大端法编码），则C程序收到的将是：\0\97\0\98\0\99，所以打印的会是空。可以看到，不管大端小端，接收到的字符序列是不会变的，都是“abc”。

### 3、C语言#include头文件的顺序问题
&emsp;&emsp;一直以为C语言中#include的头文件的顺序是没有关系，但在最近编译代码的时候却发现了问题：我在最前面又#include一个头文件后编译就报错了（expected identifier before numeric constant）。我很不能理解，然后我就想把这个头文件放到最后面好了（我当时觉得这么做很可笑，好在我还是这么做了），然后编译竟然通过了。我现在更不能理解了，这在一定程度上颠覆了我对头文件顺序的认知。虽然问题解决了，但是我还是想想知道为什么，不然我肯定“寝不安席，食不甘味”。我比较了一下两个头文件的内容，感觉没有会导致这个错误的，我当时忽略了这两个头文件里面#include的头文件的检查，后来我不经意间看到一个头文件中有这么一句：#include<stdbool.h>。这个就是定义布尔型的，但是另外一个头文件（base.h)中也有一个这样的定义：

```c
typedef enum {
 false = 0,
 true = 1
} bool;
```
报错的地方也是在这里，然后找到stdbool.h这个头文件，里面有这么一段：

```c
#define false   0
#define true    1
```
&emsp;&emsp;如果对宏很熟悉的话就会发现问题所在，如果把stdbool.h放在base.h前面的话，那么base.h中的那个定义就变成了下面这个样子：

```c
typedef enum{
    0 = 0,
    1 = 1
} bool;
```
到这里那个报错的意思就很容易理解了。肯定没有人直接写这样的代码，但是经过宏伪装后就很难说了。