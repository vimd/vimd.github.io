---
title: 插件化版本在7.0设备上崩溃分析

date: 2017-11-26 16:32:40
categories: Android
---

### 前言

&emsp;&emsp;工作中遇到一个插件化版本在7.0设备上崩溃的问题，是由于找不到资源。不过资源刚开始肯定是存在的，因为应用的首页还是能进去的。经过一番测试发现只要进H5页面就会崩溃，因此初步怀疑和WebView有关。接下来就是一段Android源码之旅，最终发现了问题的原因，并找到了一个解决方案，但是不知道是否是最优的。

### 临近封板时的大bug

&emsp;&emsp;应用的这个版本快封板时突出出现了一个大bug，插件化版本在一个设备上进入H5页面崩溃。从log看是是Android7.0，问题是找不到插件apk中的资源。资源肯定是存在的，因为已经通过hook设进去了，而且不进H5的页面也不会有问题。于是就怀疑进入H5页面的时候Resources对象有变化，而H5页面最大的不同就是使用了WebView，于是就顺着这条路开始追查。
<!--more-->
#### WebView的创建过程

&emsp;&emsp;WebView的创建最终会调用下面这个构造方法：

```java
protected WebView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes,
            Map<String, Object> javaScriptInterfaces, boolean privateBrowsing) {
        super(context, attrs, defStyleAttr, defStyleRes);
        if (context == null) {
            throw new IllegalArgumentException("Invalid context argument");
        }
        sEnforceThreadChecking = context.getApplicationInfo().targetSdkVersion >=
                Build.VERSION_CODES.JELLY_BEAN_MR2;
        checkThread();

        ensureProviderCreated();
        mProvider.init(javaScriptInterfaces, privateBrowsing);
        // Post condition of creating a webview is the CookieSyncManager.getInstance() is allowed.
        CookieSyncManager.setGetInstanceIsAllowed();
    }
```

其中在ensureProviderCreated方法如下：

```java
private void ensureProviderCreated() {
        checkThread();
        if (mProvider == null) {
            // As this can get called during the base class constructor chain, pass the minimum
            // number of dependencies here; the rest are deferred to init().
            mProvider = getFactory().createWebView(this, new PrivateAccess());
        }
    }
```

&emsp;&emsp;getFactory方法中通过调用WebViewFactory对象的getProvider返回一个WebViewChromiumFactoryProvider对象，然后调用该对象的createWebView创建WebViewChromium对象（WebViewChromiumFactoryProvider和WebViewChromium类在[源码网站](http://androidxref.com/)上没有找到，所以不贴源码了）

getProvider方法的源码如下：

```java
static WebViewFactoryProvider getProvider() {
//省略无关代码
            try {
                Class<WebViewFactoryProvider> providerClass = getProviderClass();

                try {
                    sProviderInstance = providerClass.getConstructor(WebViewDelegate.class)
                            .newInstance(new WebViewDelegate());

                    return sProviderInstance;
                }
//省略无关代码
        }
    }
```

&emsp;&emsp;getProviderClass方法返回的就是com.android.webview.chromium.WebViewChromiumFactoryProvider对应的class，从getProvider方法可以看出，调用的是WebViewChromiumFactoryProvider类带有WebViewDelegate对象的构造方法，这个WebViewDelegate对象被保存在WebViewChromiumFactoryProvider对象中，当调用WebViewChromiumFactoryProvider对象的createWebView时会创建WebViewChromium对象，在WebViewChromium的构造方法中会调用WebViewDelegate的addWebViewAssetPath
方法。这个过程在7.0之前的源码中可以看到，只不过之前的代码没有WebViewDelegate这个类。

&emsp;&emsp;至此，WebView的创建差不多结束了，但是这个似乎和要分析的问题毫无关系啊。因为最后的 一层薄纱还没有扒掉呢。

#### 系统的偷梁换柱

&emsp;&emsp;在创建WebView的过程中，系统会把浏览器apk添加到AssetManager中，在7.0中就是调用WebViewDelegate的addWebViewAssetPath。该方法源码如下：

```java
public void addWebViewAssetPath(Context context) {
        final String newAssetPath = WebViewFactory.getLoadedPackageInfo().applicationInfo.sourceDir;

        final ApplicationInfo appInfo = context.getApplicationInfo();
        final String[] libs = appInfo.sharedLibraryFiles;
        if (!ArrayUtils.contains(libs, newAssetPath)) {
            // Build the new library asset path list.
            final int newLibAssetsCount = 1 + (libs != null ? libs.length : 0);
            final String[] newLibAssets = new String[newLibAssetsCount];
            if (libs != null) {
                System.arraycopy(libs, 0, newLibAssets, 0, libs.length);
            }
            newLibAssets[newLibAssetsCount - 1] = newAssetPath;

            // Update the ApplicationInfo object with the new list.
            // We know this will persist and future Resources created via ResourcesManager
            // will include the shared library because this ApplicationInfo comes from the
            // underlying LoadedApk in ContextImpl, which does not change during the life of the
            // application.
            appInfo.sharedLibraryFiles = newLibAssets;

            // Update existing Resources with the WebView library.
            ResourcesManager.getInstance().appendLibAssetForMainAssetPath(
                    appInfo.getBaseResourcePath(), newAssetPath);
        }
    }
```

&emsp;&emsp;这个方法逻辑很简单，就是拿到WebView的apk路径，判断是否在当前ApplicationInfo的sharedLibraryFiles变量中，这个第一次调用时是不在的，所以会走到if中，把WebView的apk路径添加到sharedLibraryFiles变量中，然后调用ResourcesManager的appendLibAssetForMainAssetPath方法。下面看一下这个方法做了什么事情：

```java
public void appendLibAssetForMainAssetPath(String assetPath, String libAsset) {
850        synchronized (this) {
851            // Record which ResourcesImpl need updating
852            // (and what ResourcesKey they should update to).
853            final ArrayMap<ResourcesImpl, ResourcesKey> updatedResourceKeys = new ArrayMap<>();
854
855            final int implCount = mResourceImpls.size();
856            for (int i = 0; i < implCount; i++) {
857                final ResourcesImpl impl = mResourceImpls.valueAt(i).get();
858                final ResourcesKey key = mResourceImpls.keyAt(i);
859                if (impl != null && key.mResDir.equals(assetPath)) {
860                    if (!ArrayUtils.contains(key.mLibDirs, libAsset)) {
861                        final int newLibAssetCount = 1 +
862                                (key.mLibDirs != null ? key.mLibDirs.length : 0);
863                        final String[] newLibAssets = new String[newLibAssetCount];
864                        if (key.mLibDirs != null) {
865                            System.arraycopy(key.mLibDirs, 0, newLibAssets, 0, key.mLibDirs.length);
866                        }
867                        newLibAssets[newLibAssetCount - 1] = libAsset;
868
869                        updatedResourceKeys.put(impl, new ResourcesKey(
870                                key.mResDir,
871                                key.mSplitResDirs,
872                                key.mOverlayDirs,
873                                newLibAssets,
874                                key.mDisplayId,
875                                key.mOverrideConfiguration,
876                                key.mCompatInfo));
877                    }
878                }
879            }
880
881            // Bail early if there is no work to do.
882            if (updatedResourceKeys.isEmpty()) {
883                return;
884            }
885
886            // Update any references to ResourcesImpl that require reloading.
887            final int resourcesCount = mResourceReferences.size();
888            for (int i = 0; i < resourcesCount; i++) {
889                final Resources r = mResourceReferences.get(i).get();
890                if (r != null) {
891                    final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
892                    if (key != null) {
893                        r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
894                    }
895                }
896            }
897
898            // Update any references to ResourcesImpl that require reloading for each Activity.
899            for (ActivityResources activityResources : mActivityResourceReferences.values()) {
900                final int resCount = activityResources.activityResources.size();
901                for (int i = 0; i < resCount; i++) {
902                    final Resources r = activityResources.activityResources.get(i).get();
903                    if (r != null) {
904                        final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
905                        if (key != null) {
906                            r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
907                        }
908                    }
909                }
910            }
911        }
912    }
```

&emsp;&emsp;这个方法首先遍历value值为ResourcesImpl对象的ArrayMap，找到map中当前应用对应的ResourcesImpl和ResourcesKey（ResourcesKey的mResDir对应是某个apk的路径，通过这个字段和当前应用的apk路径比较来判断）。找到之后就把ResourcesKey的mLibDirs字段和WebView apk组合在一起，然后再创建一个新的ResourcesKey。从39行开始就是去更新已经存在的Resources对象的ResourcesImpl成员变量，对应的代码如下：

```java
private @NonNull ResourcesImpl findOrCreateResourcesImplForKeyLocked(
342            @NonNull ResourcesKey key) {
343        ResourcesImpl impl = findResourcesImplForKeyLocked(key);
344        if (impl == null) {
345            impl = createResourcesImpl(key);
346            mResourceImpls.put(key, new WeakReference<>(impl));
347        }
348        return impl;
349    }
```

&emsp;&emsp;先根据ResourcesKey查看是否存在对应的ResourcesImpl，如果存在就返回，否则就创建一个，查找的方法实现如下：

```java
 private ResourcesImpl findResourcesImplForKeyLocked(@NonNull ResourcesKey key) {
327        WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.get(key);
328        ResourcesImpl impl = weakImplRef != null ? weakImplRef.get() : null;
329        if (impl != null && impl.getAssets().isUpToDate()) {
330            return impl;
331        }
332        return null;
333    }
```

&emsp;&emsp;其实就是遍历mResourceImpls，这个方法除了第一次调用情况下返回的是null，其他情况一般返回一个ResourcesImpl对象，但是对于第一次创建WebView走到这里时也会返回null，至于原因后面会说。因此findOrCreateResourcesImplForKeyLocked方法中就会调用createResourcesImpl方法，该方法源码如下：

```java
private @NonNull ResourcesImpl createResourcesImpl(@NonNull ResourcesKey key) {
307        final DisplayAdjustments daj = new DisplayAdjustments(key.mOverrideConfiguration);
308        daj.setCompatibilityInfo(key.mCompatInfo);
309
310        final AssetManager assets = createAssetManager(key);
311        final DisplayMetrics dm = getDisplayMetrics(key.mDisplayId, daj);
312        final Configuration config = generateConfig(key, dm);
313        final ResourcesImpl impl = new ResourcesImpl(assets, dm, config, daj);
314        if (DEBUG) {
315            Slog.d(TAG, "- creating impl=" + impl + " with key: " + key);
316        }
317        return impl;
318    }
```

&emsp;&emsp;该方法最核心的就是创建一个AssetManager，然后根据这个AssetManager创建一个ResourcesImpl，创建AssetManager的方法如下：

```java
protected @NonNull AssetManager createAssetManager(@NonNull final ResourcesKey key) {
246        AssetManager assets = new AssetManager();
247
248        // resDir can be null if the 'android' package is creating a new Resources object.
249        // This is fine, since each AssetManager automatically loads the 'android' package
250        // already.
251        if (key.mResDir != null) {
252            if (assets.addAssetPath(key.mResDir) == 0) {
253                throw new Resources.NotFoundException("failed to add asset path " + key.mResDir);
254            }
255        }
256
257        if (key.mSplitResDirs != null) {
258            for (final String splitResDir : key.mSplitResDirs) {
259                if (assets.addAssetPath(splitResDir) == 0) {
260                    throw new Resources.NotFoundException(
261                            "failed to add split asset path " + splitResDir);
262                }
263            }
264        }
265
266        if (key.mOverlayDirs != null) {
267            for (final String idmapPath : key.mOverlayDirs) {
268                assets.addOverlayPath(idmapPath);
269            }
270        }
271
272        if (key.mLibDirs != null) {
273            for (final String libDir : key.mLibDirs) {
274                if (libDir.endsWith(".apk")) {
275                    // Avoid opening files we know do not have resources,
276                    // like code-only .jar files.
277                    if (assets.addAssetPathAsSharedLibrary(libDir) == 0) {
278                        Log.w(TAG, "Asset path '" + libDir +
279                                "' does not exist or contains no resources.");
280                    }
281                }
282            }
283        }
284        return assets;
285    }
```

&emsp;&emsp;这个方法逻辑很简单，就是new一个AssetManager，然后把ResourcesKey对象中各个成员变量中的apk路径添加到AssetManager对象中，然后返回，通过层层返回到appendLibAssetForMainAssetPath中，可以看到所有相关的Resouces对象的ResourcesImpl成员都被修改成一个新创建的对象，该对象的AssetManager对象也是新创建的，它只管理了当前apk（mResDir）和mLibDirs中的apk，那么，对于我们的插件化机制来说是有问题的，因为应用启动时我们hook系统方法添加的插件apk现在都不在AssetManager中了，这样使用相关资源时就出现了ResourceNotFoundException异常。

&emsp;&emsp;**对上面的分析过程总结一下：**

1.  创建WebView时最终会调用WebViewDelegate的addWebViewAssetPath方法
2. 在addWebViewAssetPath方法中会判断WebView apk是否在applicationInfo的sharedLibraryFiles变量中，第一次调用该方法时是不在其中的
3. 由于2中返回为false，所以调用ResourcesManager的appendLibAssetForMainAssetPath方法，该方法中会创建新的ResourcesKey，然后根据这个ResourcesKey创建新的ResourcesImpl和AssetManager，把新的ResourcesImpl对象设置到Resources对象中，从而间接替换掉AssetManager对象。

#### 关于Resources对象
&emsp;&emsp;前面分析findResourcesImplForKeyLocked方法时说它返回null，可是为什么呢？

&emsp;&emsp;我刚接触Android时看到网上说一个应用只有一个Resources对象，做为菜鸟，我没有深入去分析，只是被动接受了。通过打印不同的Context对象的getResources返回对象的hasCode，也间接印证了前面的说法。如果追踪getResources方法，会发现最终都会调用ResourcesManager的getResources方法（7.0之前是getTopLevelResources方法），该方法会创建一个ResourcesKey，然后调用findResourcesImplForKeyLocked方法，根据这个key到ArrayMap中查找是否存在ResourcesImpl对象，在第一次调用时，mResourceImpls为空，所以返回null，之后会创建一个ResourcesImpl对象，并把key和这个ResourcesImpl对象put到mResourceImpls中。之后再调用ResourcesManager的getResources时，由于ResourcesKey相同（可以看这个类的equals方法，ArrayMap的get方法会调用key的equals方法判断两个对象是否相同，希望到这个地方你能理解为什么前面一节分析的时候说findResourcesImplForKeyLocked返回的是null），所以会返回第一次创建的ResourcesImpl对象（这里吧ResourcesImpl和Resources等价了，因为Resources是对ResourcesImpl的封装）。这就是为什么网上很多人说一个应用只有一个Resources对象。

&emsp;&emsp;可是ResourcesManager既然是用ArrayMap管理Resources，那说明一个应用中的Resources对象有时不止一个，什么情况下会出现这种情况呢？嗯，其实这篇文章在分析的这个情况就是（只限于7.0及之后，这也是为什么7.0之前的版本我们没有遇到问题，那个时候是直接调用AssetManager的addAssetPath方法直接把WebView apk添加进去，而不会创建新的）。除此之外，还有一个情况在7.0之前的版本也会有多个Resources对象，就是sharedUserId，在manifest文件设置此属性后，就可以让两个apk运行在一个进程中，此时对于两个apk都会有一个Resources对象（因为ResourcesKey中的mResDir表示apk路径，在调用ResourcesManager的getResources时由于ResoucesKey不同，所以会创建两个ResourcesImpl对象）。

### 解决方案

&emsp;&emsp;问题找到了，如何解决呢？刚开始时是给ApplicationInfo对象的sharedLibraryFiles添加WebView apk路径，让addWebViewAssetPath方法中的判断为true，这样就不会创建新的Resources对象了。但是这样改完会有一个潜在的问题：由于ApplicationContext中的Resources对象创建的比较早（甚至在Application之前)，在应用中没有时机在第一个Resources创建之前就修改sharedLibraryFiles，所以对于ApplicationContext来说，getResources返回的Resources是没有包含WebView apk路径的，这样如果使用ApplicationContext的getResources返回的对象获取某些资源时会出现找不到的情况。

&emsp;&emsp;因此，首先要找一个尽可能早的时机来修改sharedLibraryFiles，之后又两个方案来修改ApplicationContext中的Resources对象：

1. 通过把ApplicationContext对象的成员变量mBase和mPackageInfo的mResources设置成null，然后再反射调用mPackageInfo的getResources方法，把返回的对象设置给mBase，这样就可以让ApplicationContext的getResources方法返回的对象能管理WebView apk了，具体可以查看源码，比较简单。
2. 上面一个方案的缺点是会多创建一个Resources对象，另一个方案就是在原来的Resources对象上就像修改，最重要的是修改ResourcesKey的mHash和mLibDirs。由于这样hook的地方比较多，尤其是mHash的生成算法，兼容性会比较差，因此最后还是选择了方案1.
